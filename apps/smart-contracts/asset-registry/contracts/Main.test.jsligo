#import "./Main.jsligo" "Contract"
#import "./data/tokenMetadata.jsligo" "TokenMetadata"

const initial_storage = {
  metadata: Big_map.empty as Contract.Generic.Metadata.t,
  assets: Big_map.empty as Contract.Generic.Ledger.NFT.L,
  token_metadata: Big_map.empty as Contract.Generic.TokenMetadata.T,
  operators: Some(Big_map.empty as Contract.Generic.Operators.t),
  approvals: Big_map.empty as Contract.Generic.Approvals.T,
};

const run_mint_test = () => {
    const _admin_account = Test.Next.Account.address(0n);
    const user_account = Test.Next.Account.address(1n);

    const orig = Test.Next.Originate.contract(contract_of(Contract), initial_storage, 0tez);
    const args: Contract.Generic.Mint.MintParam = {
      to_: user_account as address,
      token_id: 0n,
      amount: 1n,
      token_info: Some(Map.literal([
        ["", bytes`ipfs://tokenMetadataCID`]
      ]))
    };
    const _result = Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("mint", orig.taddr), args, 0tez);

    const new_storage = {
      metadata: Big_map.empty as Contract.Generic.Metadata.t,
      assets: Big_map.literal([
        [0n, user_account]
      ]) as Contract.Generic.Ledger.NFT.L,
      token_metadata: Big_map.literal([
        [0n, {
          token_id: 0n,
          token_info: Map.literal([
            ["", bytes`ipfs://tokenMetadataCID`]
          ])
        }]
      ]),
      operators: Some(Big_map.empty as Contract.Generic.Operators.t),
      approvals: Big_map.empty as Contract.Generic.Approvals.T,
    } as Contract.Storage;

    return Assert.assert(Test.Next.Compare.eq(Test.Next.Typed_address.get_storage(orig.taddr), new_storage));
};

const test_mint = run_mint_test();

const run_test_transfer = () => {
    Test.Next.State.reset(3n, [] as list <tez>);
    const admin = Test.Next.Account.address(0n);
    const bob = Test.Next.Account.address(1n);
    const alice = Test.Next.Account.address(2n);
    const orig = Test.Next.Originate.contract(contract_of(Contract), initial_storage, 0tez);
    
    const mint_args: Contract.Generic.Mint.MintParam = {
      to_: bob as address,
      token_id: 0n,
      amount: 1n,
      token_info: Some(Map.literal([
        ["", bytes`ipfs://tokenMetadataCID`]
      ]))
    };
    Test.Next.State.set_source(admin);
    const _mint_result = Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("mint", orig.taddr), mint_args, 0tez);

    const transfer_args: Contract.Generic.Transfer.t = [{
      from_: bob as address,
      txs: [{
        to_: alice as address,
        token_id: 0n,
        amount: 1n
      }]
    }];

    Test.Next.State.set_source(bob);
    const _transfer_result = Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("transfer", orig.taddr), transfer_args, 0tez);
    const new_storage = Test.Next.Typed_address.get_storage(orig.taddr);
    
    Assert.assert(Test.Next.Compare.eq(Big_map.find_opt(0n, new_storage.assets), Some(alice)));
    return Assert.assert(Test.Next.Compare.eq(Test.Next.Typed_address.get_storage(orig.taddr), new_storage));
};

const test_transfer = run_test_transfer();

const run_test_update_operators = () => {
  const admin = Test.Next.Account.address(0n);
  const bob = Test.Next.Account.address(1n);

  const orig = Test.Next.Originate.contract(contract_of(Contract), initial_storage, 0tez);

  const mint_args: Contract.Generic.Mint.MintParam = {
    to_: bob as address,
    token_id: 0n,
    amount: 1n,
    token_info: Some(Map.literal([
      ["", bytes`ipfs://tokenMetadataCID`]
    ]))
  };

  Test.Next.State.set_source(admin);
  const _mint_result = Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("mint", orig.taddr), mint_args, 0tez);

  const update_operators_args = [
    AddOperator( {
      owner: bob as address,
      operator: admin as address,
      token_id: 0n
    })
  ];

  Test.Next.State.set_source(bob);
  const _update_operators_result = Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("update_operators", orig.taddr), update_operators_args, 0tez);
  const new_storage = Test.Next.Typed_address.get_storage(orig.taddr);

  return Assert.assert(Test.Next.Compare.eq(Big_map.find_opt([bob, 0n], Option.value_with_error("No Operators", new_storage.operators)), Some(Set.literal([admin]))));
}

const test_update_operators = run_test_update_operators();
